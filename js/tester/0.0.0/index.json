{
  "title": "tester",
  "url": "js/tester/0.0.0",
  "content": "         &lt;title&gt;John Henry&lt;/title&gt; &lt;link rel=&quot;canonical&quot; href=&quot;https://johnhenry.github.io/&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;John Henry&#39;s Person Portfolio and Blog&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#343233&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;fun,math,engineering,science,experiments,programming&quot; /&gt; &lt;meta name=&quot;author&quot; content=&quot;John Henry&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;https://johnhenry.github.io/image/iajh.png&quot; type=&quot;image/png&quot; /&gt;         # Tester    ../js/tester@latest/index.mjs   Tester is a javascript testing framework based on  Tape .   Like Tape, tester     can be run directly using  node  without any additional binaries or transformations.   produces output using the standard  Test Anything Protocol .     Unlike Tape, tester     can be run directly in the browser or using  deno  without any additional binaries/transformations, along with node.   uses external assertions and makes it easy to write your own.     API   Tester's API consist of two manin components:     The &quot;tester&quot; function acts on a group of assertions.   The assertions themselves, which return errors if a given condition is not satisfied.     Tester   The tester function is the default export.   It takes as its only argument a [possibly asynchronous] generator. We call this a &quot;test&quot;.   Results of assertions are yielded from within the body of a test.      import  tester  from   &quot;./index.mjs&quot;  ;   tester ( function  *  ()  {   yield   /*some assertion result*/  ;   yield   /*some other assertion result*/  ;   } ) ;      Assertions   The named exports are assertions.   Call them within a test and yield their results.      import  tester ,   {  ok ,  notok  }   from   &quot;./index.mjs&quot;  ;   tester ( function  *  ()  {   yield   ok ( true ) ;   yield   notok ( false ) ;   } ) ;      Included Assertions   Besides ok and notok, there are a number of assertions included:     ok -- test passes if and only if the given argument to a test is TRUTHY.   notok -- test passes if and only if the given argument to a test is FALSH.   equal -- test passes if and only if the two given arguments are THE SAME object.   notequal -- test passes if and only if the two given arguments are NOT THE SAME object.   pass -- test ALWAYS PASSES   fail -- test ALWAYS FAILS   subtestpass -- test passes if and only if the given argument is a test in which ALL THE ASSERTIONS PASS.   subtestfail -- test passes if and only if the given argument is a test in which AT LEAST ONE ASSERTION FAILS.   throws -- test passes if and only if the given function THROWS AN ERROR when called   doesnotthrow -- test passes if and only if the given function DOES NOT THROW AN ERROR when called     plan   When using the run function, the first argument passed to given generator is a function. We'll call it &quot;plan&quot;, but you can name it anyting you like (&quot;expect&quot;, &quot;assertions&quot;, etc.) When  plan  is called with an integer, it dictates the number of expected assertions in a given test function.   import tester, { ok } from &quot;./index.mjs&quot;;      tester ( function  *  (plan)  {   plan ( 1 ) ;   yield   ok ( true ) ;   } ) ;      Creating Assertions   When creating assertions, use the examples in  ./assertions  for inspiration. Here are a few things to keep in mind:     Assertions are functions that test for a desired conditon.   If the given conditions meet the desired conditions,   an accepted message is returned.   Otherwise, an instance of TestError is returned.        import  TestError  from   &quot;./testerror.mjs&quot;  ;   const  assertion  =  ( /*given conditions*/ ) =&gt;{   if ( /*conditions are met*/ ) {   return   /*some message*/  ;   }   return   new   TestError ( /*some message*/ ) ;   }      Conventions   This library follows a specific convetion for its assertions. It's recommended that you follow these conventions when creating your own assertions, but feel free to come up with your own.     The last item is an  operator string , which is used for the TAP protocol and can be overridden.   The next-to-last item is a  default expected message  that can also be overridden.   The preceeding arguments are given conditions to be tested.   The returned TestError is constructed using the default expected message along with an object detailing the difference between what's expected and what's not.        import  TestError  from   &quot;./testerror.mjs&quot;  ;   const  assertion  =  ( /*given conditions*/  ,  message ,  operatorString) =&gt;{   if ( /*conditions are met*/ ) {   return  message ;   }   return   new   TestError (message ,   /*some object*/ )) ;   }      TestError API   The test error is constructed with two items:     An expected messages   An object who's key-value pairs are displayed as part of TAP output     Tester   A context-independent testing framework inspired by  tape .   context-agnostic   Tests run in same context as your application. No special executables needed.   TAP Output   Tester outputs to the console using a partial implementation of the  Test Anything Protocol .   Usage   The default export of ./index.mjs is an asynchronous function,  tester , that takes a test in the form of an asynchronous iterator.      import  tester  from   &quot;./index.mjs&quot;  ;  await  tester (async  function  *  ()  {   /* define test here s*/   } ) ;      Title   Optionally  tester  takes a string as it's first argument. This will be printed out before each test.      import  tester  from   &quot;./index.mjs&quot;  ;  await  tester ( &quot;test title&quot;  ,  async  function  *  ()  {   /* define test here s*/   } ) ;      Definition and format   When creating a test, simply yield the result of an assertion.      import  tester  from   &quot;./index.mjs&quot;  ;   import  ok  from   &quot;./assertions/ok.mjs&quot;  ;  await  tester ( &quot;test title&quot;  ,  async  function  *  ()  {   yield   ok ( true ) ;   } ) ;      There are 7 built in assertions included alongside the default export for convinience.      import  tester ,   {  ok ,  notok ,  equal ,  notequal ,  deepequal ,  pass ,  fail ,   }   from   &quot;./index.mjs&quot;  ;      with plan argument   The first argument to the test is a  plan  function which is used to announce then number of tests before they take place via TAP.      import  tester  from   &quot;./index.mjs&quot;  ;   import  ok  from   &quot;./assertions/ok.mjs&quot;  ;  await  tester ( &quot;test title&quot;  ,  async  function  *  (plan)  {   plan ( 1 ) ;   yield   ok ( true ) ;   } ) ;      assetions   Assertions are functions. They take any number of arguments and return either a success message string or an instance of TestError (&quot;/testerror.mjs&quot;).   included assertions   ok      import   {  ok  }   from   &quot;/index.mjs&quot;  ;   const  result  =   ok ( true ) ;   if  (result  instanceof  Error)  {   throw  result ;   }      notok      import   {  notok  }   from   &quot;/index.mjs&quot;  ;   const  result  =   notok ( false ) ;   if  (result  instanceof  Error)  {   throw  result ;   }      equal      import   {  equal  }   from   &quot;/index.mjs&quot;  ;   const  result  =   equal ( true  ,   true ) ;   if  (result  instanceof  Error)  {   throw  result ;   }      notequal      import   {  notequal  }   from   &quot;./index.mjs&quot;  ;   const  result  =   notequal ( true  ,   false ) ;   if  (result  instanceof  Error)  {   throw  result ;   }      deepequal      import   {  deepequal  }   from   &quot;./index.mjs&quot;  ;   const  result  =   deepequal ( {   a  :   true   },   {   a  :   true   } ) ;   if  (result  instanceof  Error)  {   throw  result ;   }      pass      import   {  pass  }   from   &quot;./index.mjs&quot;  ;   const  result  =   pass () ;   if  (result  instanceof  Error)  {   throw  result ;   }      fail      import   {  fail  }   from   &quot;./index.mjs&quot;  ;   const  result  =   fail () ;   if  (result  instanceof  Error)  {   throw  result ;   }      subtestpass      import   {  subtestpass ,  pass  }   from   &quot;./index.mjs&quot;  ;   const  result  =  await  subtestpass ( function  *  ()  {   yield   pass () ;   } ) ;   if  (result  instanceof  Error)  {   throw  result ;   }      subtestfail      import   {  subtestfail ,  fail  }   from   &quot;./index.mjs&quot;  ;   const  result  =  await  subtestfail ( function  *  ()  {   yield   fail () ;   } ) ;   if  (result  instanceof  Error)  {   throw  result ;   }      creating external assertions   Assertions have the following general form:      export   default  (... args )  =&gt;   {   if ( /*test of args passes*/ ) {   // return a string to indicate success.   }   else   {   // return instance of TestError   }   }      TAPRunner, print, run   The file &quot;/TAPRunner.mjs&quot; export methods &quot;print&quot; and &quot;run&quot;. &quot;print&quot; functions similarly to the default export of &quot;index.mjs&quot; -- both of which rely on &quot;run&quot; to execute underlying code.  When called with as single argument (a test), &quot;run&quot; yields only the results of the test (string or Error) without additional processing.     "
}
